\pagebreak
\section{Nền tảng toán học và triển khai mô hình}
\subsection{Nền tảng toán học}
\subsubsection{Mô hình Softmax Regression}
Mô hình \textit{Softmax Regression} được sử dụng để giải quyết bài toán phân loại đa lớp (\textit{multi-class classification}) trên tập dữ liệu MNIST. Với một mẫu đầu vào được biểu diễn bởi vector đặc trưng $\displaystyle x \in \mathbb{R}^{d}$ (trong đó $d$ là số chiều của không gian đặc trưng), mô hình trước tiên tính toán điểm số tuyến tính (logits) tương ứng với $K$ lớp thông qua phép biến đổi sau:
\begin{center}
    $\displaystyle z = Wx+b$.
\end{center}
Trong đó:
\begin{itemize}
    \item $W \in \mathbb{R}^{K \times d}$ là ma trận trọng số;
    \item $b \in \mathbb{R}^{K}$ là vector bias;
    \item $z \in \mathbb{R}^{K}$ là vector điểm số.
\end{itemize}
Để chuyển các điểm số tuyến tính $z$ thành một phân phối xác suất hợp lệ trên không gian nhãn, mô hình sử dụng hàm kích hoạt \textit{softmax}. Xác suất để mẫu $x$ thuộc lớp $k$ được xác định bởi:
\begin{center}
    $\displaystyle \hat{y}_k = P(y = k | x) = softmax(z_k) = \frac{e^{z_k}}{\sum_{j=1}^{K} e^{z_j}}$.
\end{center}
Trong đó, $z_k$ là điểm số ứng với lớp $k$, và mẫu số $\sum_{j=1}^{K} e^{z_j}$ đảm bảo rằng tổng các xác suất bằng 1, tạo thành một phân phối xác suất chuẩn hóa trên $K$ lớp.
\subsubsection{Hàm mất mát (Loss Function)}
Để huấn luyện mô hình, ta sử dụng hàm mất mát \textit{Cross-Entropy} nhằm đo lường mức độ khác biệt giữa phân phối xác suất dự đoán và nhãn thực tế. Đồng thời, nhằm hạn chế hiện tượng quá khớp (\textit{overfitting}), một thành phần điều chuẩn L2 (\textit{L2 Regularization}) được bổ sung vào hàm mất mát tổng quát. Cụ thể, hàm mất mát được định nghĩa như sau:
\begin{center}
    $\displaystyle J(W, b) = - \frac{1}{N} \sum_{i=1}^{N} \sum_{k=1}^{K} y_{i,k} \log \hat{y}_{ik} + \frac{\lambda}{2} \sum_{l} \sum_{m} W_{lm}^2$.
\end{center}
Trong đó:
\begin{itemize}
    \item $N$ là số lượng mẫu trong một batch;
    \item $y_{i,k}$ là thành phần của vector one-hot label (bằng 1 nếu mẫu $i$ thuộc lớp $k$, ngược lại bằng 0);
    \item $\lambda$ (ký hiệu là \texttt{reg} trong mã nguồn) là hệ số điều chuẩn.
\end{itemize}
Trong biểu thức trên, hạng tử cross-entropy (hạng tử thứ nhất) thúc đẩy mô hình tối đa hóa xác suất dự đoán đúng, trong khi hạng tử điều chuẩn (hạng tử thứ hai) giúp giới hạn độ lớn của các trọng số, từ đó nâng cao khả năng tổng quát hóa của mô hình.
\subsubsection{Giải thuật tối ưu Gradient Descent}
Quá trình huấn luyện mô hình được thực hiện bằng thuật toán \textit{Mini-batch Gradient Descent}. Ở mỗi bước lặp, ta tính gradient của hàm mất mát đối với các tham số $W$ và $b$. Nhờ đặc tính giải tích thuận lợi của hàm softmax khi kết hợp với hàm mất mát cross-entropy, các biểu thức đạo hàm thu được có dạng đơn giản và hiệu quả như sau:
\begin{center}
    $\displaystyle \frac{\partial J}{\partial z} = \hat{y} - y$,
    $\displaystyle \frac{\partial J}{\partial W} = \frac{1}{N} X^T (\hat{y}-y) + \lambda W$,
    $\displaystyle \frac{\partial J}{\partial b} = \frac{1}{N} \sum (\hat{y}-y)$.
\end{center}
Trong đó $X \in \mathbb{R}^{N \times d}$ là ma trận dữ liệu đầu vào của mini-batch gồm $N$ mẫu.\\
Quy tắc cập nhật tham số với tốc độ học $\alpha$ (\textit{learning rate}) được thể hiện như sau:
\begin{center}
    $\displaystyle W \leftarrow W - \alpha \frac{\partial J}{\partial W}$,
    $\displaystyle b \leftarrow b - \alpha \frac{\partial J}{\partial b}$.
\end{center}
Nhờ việc sử dụng mini-batch, quá trình tối ưu vừa duy trì sự ổn định của gradient, vừa đảm bảo hiệu năng tính toán phù hợp cho các tập dữ liệu lớn.\\
Trước khi đi vào quy trình huấn luyện lặp, ta cần xác định cách khởi tạo tham số và chi tiết các bước tính toán giá trị mất mát cũng như đạo hàm tại mỗi bước lặp. Các hàm này tương ứng với phương thức \texttt{\_\_init\_\_} và \texttt{compute\_loss\_and\_grads} trong mã nguồn cài đặt.
\begin{algorithm}[H]
\caption{Khởi tạo và Tính toán Loss/Gradient}
\begin{algorithmic}
\Function{Initialize}{$n\_features, n\_classes, lr, reg$}
    \State $self.lr \gets lr$
    \State $self.reg \gets reg$
    \Comment{Khởi tạo ngẫu nhiên nhỏ để phá vỡ tính đối xứng}
    \State $W \gets 0.01 \times \mathcal{N}(0, 1, (n\_classes, n\_features))$
    \State $b \gets \vec{0}_{n\_classes}$
\EndFunction

\Statex % Khoảng trống phân cách

\Function{ComputeLossAndGrads}{$X, y$}
    \State $N \gets \text{rows}(X)$
    
    \State \textbf{1. Forward Pass:}
    \State $scores \gets X W^\top + b$
    \State $probs \gets \text{Softmax}(scores)$ \Comment{Sử dụng max-subtraction để ổn định số học}
    
    \State \textbf{2. Compute Loss (Data + Regularization):}
    \State $correct\_logprobs \gets -\log(probs[\text{range}(N), y] + \epsilon)$
    \State $data\_loss \gets \text{Mean}(correct\_logprobs)$
    \State $reg\_loss \gets 0.5 \cdot reg \cdot \sum(W \circ W)$
    \State $loss \gets data\_loss + reg\_loss$
    
    \State \textbf{3. Backward Pass (Gradient):}
    \State $dscores \gets probs$
    \State $dscores[\text{range}(N), y] \gets dscores[\text{range}(N), y] - 1$
    \State $dscores \gets dscores / N$
    
    \State $\nabla_W \gets dscores^\top X$
    \If {$reg > 0$}
        \State $\nabla_W \gets \nabla_W + reg \cdot W$
    \EndIf
    \State $\nabla_b \gets \text{Sum}(dscores, \text{axis}=0)$
    
    \State \Return $(loss, \nabla_W, \nabla_b)$
\EndFunction
\end{algorithmic}
\end{algorithm}

Đoạn mã giả trên mô tả chi tiết hai quá trình:
\begin{itemize}
    \item \textbf{Initialize}: Thiết lập ma trận trọng số $W$ với các giá trị ngẫu nhiên nhỏ theo phân phối chuẩn và bias $b$ bằng 0. Việc này giúp mô hình hội tụ tốt hơn so với khởi tạo bằng 0.
    \item \textbf{ComputeLossAndGrads}: Thực hiện tính toán xuôi (forward) để lấy xác suất dự đoán, sau đó tính toán ngược (backward) để xác định gradient. Lưu ý rằng gradient của trọng số $\nabla_W$ bao gồm cả thành phần đạo hàm từ \textit{Regularization} ($reg \cdot W$).
\end{itemize}

\subsubsection{Quy trình huấn luyện mô hình}
\begin{algorithm}
\caption{Hàm huấn luyện \texttt{fit}}
\begin{algorithmic}
\Function{fit}{$X_{train}, y_{train}, X_{val}, y_{val}, epochs, batch\_size$}
    \State $N \gets \text{rows}(X_{train})$
    \State $history.train\_loss \gets [\,]$
    \State $history.val\_acc \gets [\,]$
    \For {$epoch \gets 1 \text{ to } epochs$}
        \State $indices \gets \text{RandomPermutation}(\{0,\dots,N-1\})$
        \State $X_{train} \gets X_{train}[indices]$
        \State $y_{train} \gets y_{train}[indices]$
        \State $epoch\_loss \gets 0$
        \State $n\_batches \gets 0$
        \For {$start \gets 0 \text{ to } N \text{ step } batch\_size$}
            \State $end \gets start + batch\_size$
            \State $X_{batch} \gets X_{train}[start:end]$
            \State $y_{batch} \gets y_{train}[start:end]$
            \State $(L, \nabla_W, \nabla_b) \gets \text{ComputeLossAndGrads}(X_{batch}, y_{batch})$
            \State $epoch\_loss \gets epoch\_loss + L$
            \State $n\_batches \gets n\_batches + 1$
            \State $W \gets W - lr \cdot \nabla_W$
            \State $b \gets b - lr \cdot \nabla_b$
        \EndFor
        \State $avg\_loss \gets epoch\_loss / \max(n\_batches, 1)$
        \State $history.train\_loss.\text{append}(avg\_loss)$
        \If {$X_{val} \neq \emptyset \text{ and } y_{val} \neq \emptyset$}
            \State $\hat{y}_{val} \gets \text{Predict}(X_{val})$
            \State $val\_acc \gets \text{Mean}(\hat{y}_{val} = y_{val})$
            \State $history.val\_acc.\text{append}(val\_acc)$
        \EndIf
    \EndFor
    \State \Return $history$
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{itemize}
    \item Xáo trộn (\emph{shuffle}) tập huấn luyện ở đầu mỗi epoch bằng một hoán vị ngẫu nhiên các chỉ số.
    \item Chia dữ liệu đã xáo trộn thành các mini-batch có kích thước \texttt{batch\_size}.
    \item Với mỗi mini-batch, gọi \texttt{ComputeLossAndGrads} để tính giá trị hàm mất mát và gradient theo $W$, $b$.
    \item Cập nhật tham số theo quy tắc gradient descent: $W \leftarrow W - \text{lr} \cdot \nabla_W$, $b \leftarrow b - \text{lr} \cdot \nabla_b$.
    \item Tính loss trung bình của toàn bộ các mini-batch trong một epoch và lưu vào \texttt{history.train\_loss}.
    \item Nếu có tập validation, tính độ chính xác trên $X_{\text{val}}$ và lưu vào \texttt{history.val\_acc}.
\end{itemize}

\subsubsection{Quy trình suy diễn và dự đoán}
\begin{algorithm}
\caption{Hàm suy diễn \texttt{predict\_proba} và \texttt{predict}}
\begin{algorithmic}
\Function{predict\_proba}{$X$}
    \State $Z \gets X W^\top + b$
    \State $Z' \gets Z - \max(Z \text{ theo từng hàng})$
    \State $expZ \gets \exp(Z')$
    \State $P \gets expZ / \sum(expZ \text{ theo từng hàng})$
    \State \Return $P$
\EndFunction

\Statex

\Function{predict}{$X$}
    \State $P \gets \text{predict\_proba}(X)$
    \State $\hat{y} \gets \arg\max(P \text{ theo từng hàng})$
    \State \Return $\hat{y}$
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{itemize}
    \item \texttt{predict\_proba}:
    \begin{itemize}
        \item Tính điểm số tuyến tính $Z = X W^\top + b$ cho tất cả mẫu và tất cả lớp.
        \item Chuẩn hoá $Z$ theo từng hàng để ổn định số học, sau đó áp dụng hàm softmax để thu được ma trận xác suất $P$.
    \end{itemize}
    \item \texttt{predict}:
    \begin{itemize}
        \item Gọi lại \texttt{predict\_proba} để lấy phân phối xác suất trên các lớp cho từng mẫu.
        \item Chọn lớp có xác suất lớn nhất bằng toán tử $\arg\max$ theo chiều lớp, thu được vector nhãn dự đoán $\hat{y}$.
    \end{itemize}
\end{itemize}

